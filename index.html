<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interstellar Math | Three.js Morphing</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Share Tech Mono', monospace;
            color: #0ff;
            user-select: none;
        }

        /* Canvas Container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HUD Overlay Layer */
        #hud-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas where needed */
        }

        /* Top Left Info Panel */
        .panel-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            border-left: 2px solid rgba(0, 255, 255, 0.5);
            padding-left: 15px;
            background: linear-gradient(90deg, rgba(0, 20, 40, 0.6) 0%, rgba(0,0,0,0) 100%);
        }

        /* AI Log Panel (New) */
        .panel-ai-log {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            border-right: 2px solid rgba(0, 255, 255, 0.5);
            padding-right: 15px;
            text-align: right;
            background: linear-gradient(-90deg, rgba(0, 20, 40, 0.6) 0%, rgba(0,0,0,0) 100%);
            font-size: 13px;
            color: #bde;
            text-shadow: 0 0 2px #0ff;
        }
        
        .ai-title {
            font-family: 'Orbitron', sans-serif;
            color: #ff00ff;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .ai-content {
            min-height: 60px;
            white-space: pre-wrap;
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 14px;
            background-color: #0ff;
            animation: blink 1s infinite;
            vertical-align: middle;
        }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            margin: 0 0 5px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #0ff;
        }

        .data-row {
            font-size: 14px;
            line-height: 1.5;
            color: rgba(0, 255, 255, 0.8);
            display: flex;
            align-items: center;
        }

        .data-value {
            color: #fff;
            margin-left: 10px;
            font-weight: bold;
        }

        /* Bottom Controls */
        .controls-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            pointer-events: auto; /* Enable clicks */
            background: rgba(0, 10, 20, 0.6);
            padding: 15px 30px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            align-items: center;
        }

        /* Sci-Fi Buttons */
        .sci-fi-btn {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #0ff;
            color: #0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            padding: 10px 24px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }
        
        /* Specific styles for AI buttons */
        .btn-ai {
            border-color: #a0f;
            color: #e0f;
        }
        
        .btn-ai:hover {
            background: rgba(180, 0, 255, 0.2);
            box-shadow: 0 0 15px #a0f;
        }

        .sci-fi-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 15px #0ff;
            text-shadow: 0 0 5px #fff;
        }

        .sci-fi-btn:active {
            transform: scale(0.95);
        }

        .sci-fi-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.4), transparent);
            transition: 0.5s;
        }
        
        .btn-ai::before {
             background: linear-gradient(90deg, transparent, rgba(200, 0, 255, 0.4), transparent);
        }

        .sci-fi-btn:hover::before {
            left: 100%;
        }

        /* Visual Decor Elements */
        .corner-bracket {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 255, 255, 0.6);
            transition: all 0.5s ease;
        }
        .top-right { top: 20px; right: 20px; border-bottom: none; border-left: none; }
        .bottom-right { bottom: 20px; right: 20px; border-top: none; border-left: none; }
        
        /* Scanline effect */
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 9;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(0, 255, 255, 0.04) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100%; }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0ff;
            font-size: 20px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        /* Loading spinner for AI */
        .ai-loading {
            display: inline-block;
            width: 10px;
            height: 10px;
            border: 2px solid #a0f;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
            display: none;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Three.js Container -->
    <div id="canvas-container"></div>

    <!-- HUD Interface -->
    <div id="hud-layer">
        <div class="scanline"></div>
        
        <div class="panel-top-left">
            <h1>SYSTEM: <span style="color:white">MATH_VISUALIZER</span></h1>
            <div class="data-row">TARGET: <span id="shape-name" class="data-value">INITIALIZING...</span></div>
            <div class="data-row">PARTICLES: <span class="data-value">30,000</span></div>
            <div class="data-row">FPS: <span id="fps-counter" class="data-value">--</span></div>
            <div class="data-row">SPEED: <span id="speed-display" class="data-value">1.0x</span></div>
            <div class="data-row">STATUS: <span id="status-text" class="data-value" style="color:#0f0">STABLE</span></div>
        </div>

        <!-- AI Log Panel -->
        <div class="panel-ai-log">
            <div class="ai-title">SHIP AI LOG <span class="ai-loading" id="ai-spinner"></span></div>
            <div class="ai-content" id="ai-output">Waiting for query...<span class="cursor"></span></div>
        </div>

        <div class="corner-bracket top-right"></div>
        <div class="corner-bracket bottom-right"></div>

        <div class="controls-container">
            <button class="sci-fi-btn" id="btn-switch">SWITCH FORM</button>
            <button class="sci-fi-btn" id="btn-speed">SPEED BOOST</button>
            <div style="width: 1px; height: 30px; background: rgba(0,255,255,0.3); margin: 0 10px;"></div>
            <button class="sci-fi-btn btn-ai" id="btn-analyze">ANALYZE ✨</button>
            <button class="sci-fi-btn btn-ai" id="btn-nav">NAVIGATE ✨</button>
        </div>
    </div>

    <div id="loading">GENERATING QUANTUM DATA...</div>

    <!-- Libraries -->
    <!-- Three.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Controls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Configuration ---
        const PARTICLE_COUNT = 30000;
        const PARTICLE_SIZE = 0.15;
        const ANIMATION_SPEED_BASE = 0.03;
        const apiKey = ""; // API Key provided by environment
        let morphSpeed = ANIMATION_SPEED_BASE;
        
        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        let particles, geometry;
        let positions = []; // Current positions
        let targetPositions = []; // Target shape positions
        let colors = [];
        
        // Shapes registry
        const SHAPES = [
            'Cardioid',
            'Lemniscate',
            'Logarithmic Spiral',
            'Trefoil Knot',
            'Grandi Rose',
            'Astroid',
            'Butterfly Curve',
            'Julia Set (Attractor)'
        ];
        let currentShapeIndex = 0;
        let isMorphing = false;
        let frameCount = 0;
        let lastTime = performance.now();

        // --- Init Function ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            camera.position.y = 10;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post Processing (Bloom)
            const renderScene = new THREE.RenderPass(scene, camera);
            
            // Resolution, Strength, Radius, Threshold
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 2.0; // Glow intensity
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // Initialize Particles
            createParticles();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('btn-switch').addEventListener('click', nextShape);
            document.getElementById('btn-speed').addEventListener('click', toggleSpeed);
            document.getElementById('btn-analyze').addEventListener('click', triggerAIAnalysis);
            document.getElementById('btn-nav').addEventListener('click', triggerAINavigation);
            
            window.addEventListener('keydown', (e) => {
                if(e.code === 'Space') nextShape();
            });

            // Start Loop
            document.getElementById('loading').style.opacity = 0;
            updateHUD(SHAPES[0]);
            generateTarget(0); // Generate first shape
            animate();
        }

        // --- AI & Gemini Integration ---

        async function callGemini(prompt) {
            const spinner = document.getElementById('ai-spinner');
            spinner.style.display = 'inline-block';
            
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!response.ok) throw new Error('Comms link failed');
                
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "NO DATA RECEIVED.";
                return text;
            } catch (error) {
                console.error(error);
                return "ERROR: UPLINK FAILED. CHECK CONNECTION.";
            } finally {
                spinner.style.display = 'none';
            }
        }

        async function triggerAIAnalysis() {
            const shape = SHAPES[currentShapeIndex];
            const outputEl = document.getElementById('ai-output');
            outputEl.innerHTML = "SCANNING GEOMETRY...<span class='cursor'></span>";
            
            const prompt = `You are a sci-fi spaceship AI (like TARS or HAL). 
            We are currently observing a particle construct shaped like a '${shape}'. 
            Analyze its mathematical beauty and theoretical properties in a cool, scientific way. 
            Keep it under 30 words. Output plain text only.`;

            const text = await callGemini(prompt);
            typeWriterEffect(text, outputEl);
        }

        async function triggerAINavigation() {
            const shape = SHAPES[currentShapeIndex];
            const outputEl = document.getElementById('ai-output');
            outputEl.innerHTML = "CALCULATING TRAJECTORY...<span class='cursor'></span>";
            
            const prompt = `You are a sci-fi spaceship AI. 
            The crew wants to jump to hyperspace through the current '${shape}' formation. 
            Generate a fictional coordinate (e.g., Sector 7G) and a short warning about the destination.
            Keep it under 30 words. Output plain text only.`;

            const text = await callGemini(prompt);
            typeWriterEffect(text, outputEl);
        }

        function typeWriterEffect(text, element) {
            element.innerHTML = ""; // Clear
            let i = 0;
            const speed = 30; // ms
            
            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    element.innerHTML += "<span class='cursor'></span>";
                }
            }
            type();
        }

        // --- Particle System ---
        function createParticles() {
            geometry = new THREE.BufferGeometry();
            
            const posArray = new Float32Array(PARTICLE_COUNT * 3);
            const colorArray = new Float32Array(PARTICLE_COUNT * 3);
            
            // Random initial positions (Big Bang)
            for(let i = 0; i < PARTICLE_COUNT; i++) {
                positions.push(0, 0, 0); // Logic array
                
                posArray[i*3] = (Math.random() - 0.5) * 100;
                posArray[i*3+1] = (Math.random() - 0.5) * 100;
                posArray[i*3+2] = (Math.random() - 0.5) * 100;

                // Initial Colors (Sci-Fi Palette: Cyan to Blue to Purple)
                const c = new THREE.Color();
                c.setHSL(0.5 + Math.random() * 0.2, 1.0, 0.6);
                colorArray[i*3] = c.r;
                colorArray[i*3+1] = c.g;
                colorArray[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- Math Generators ---
        // Fills the targetPositions array based on the selected shape index
        function generateTarget(shapeIndex) {
            targetPositions = [];
            const scale = 12; 

            for(let i = 0; i < PARTICLE_COUNT; i++) {
                // Normalized index 0 to 1 (or 0 to 2PI etc based on need)
                const t = (i / PARTICLE_COUNT) * Math.PI * 2.0; 
                // For 2D surfaces mapping
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;

                let x = 0, y = 0, z = 0;

                switch(shapeIndex) {
                    case 0: // Cardioid (Heart-ish 3D rotation)
                    {
                        // 2D Cardioid rotated to form a bulb
                        const phi = u; 
                        const theta = v * 2; // more distribution
                        // r = 1 - cos(theta)
                        const r = (1 - Math.cos(theta)) * scale;
                        x = r * Math.sin(theta) * Math.cos(phi);
                        y = r * Math.cos(theta); // Up/Down
                        z = r * Math.sin(theta) * Math.sin(phi);
                        y += 5; // center it
                    }
                    break;

                    case 1: // Lemniscate of Bernoulli (Infinity)
                    {
                        // Parametric form
                        const tLev = (i / PARTICLE_COUNT) * Math.PI * 2; 
                        // Add some thickness/randomness
                        const jitter = (Math.random() - 0.5) * 2; 
                        
                        const denom = 1 + Math.sin(tLev) * Math.sin(tLev);
                        const r = scale * 1.5;
                        x = (r * Math.cos(tLev)) / denom;
                        y = (r * Math.sin(tLev) * Math.cos(tLev)) / denom;
                        z = (Math.random() - 0.5) * 3; // Slight thickness
                        
                        // Create a cloud version
                        x += (Math.random()-0.5);
                        y += (Math.random()-0.5);
                    }
                    break;

                    case 2: // Logarithmic Spiral (Galaxy)
                    {
                        const a = 0.5;
                        const b = 0.2;
                        const angle = i * 0.01; // Many turns
                        const rad = a * Math.exp(b * (angle % 20)); // Limit growth
                        
                        // Add noise for galaxy arms
                        const armOffset = (Math.random() - 0.5) * (rad * 0.2);
                        
                        x = (rad + armOffset) * Math.cos(angle);
                        z = (rad + armOffset) * Math.sin(angle);
                        y = (Math.random() - 0.5) * (10 / (rad + 1)) * 5; // Thicker at center
                        
                        // Rotate to face camera
                        const tempY = y;
                        y = x * Math.sin(1) + y * Math.cos(1);
                        x = x * Math.cos(1) - tempY * Math.sin(1);
                    }
                    break;

                    case 3: // Trefoil Knot
                    {
                        const t = (i / PARTICLE_COUNT) * Math.PI * 20; // Multiple loops to fill lines
                        const r = scale * 0.6;
                        x = r * (Math.sin(t) + 2 * Math.sin(2 * t));
                        y = r * (Math.cos(t) - 2 * Math.cos(2 * t));
                        z = r * (-Math.sin(3 * t));
                        
                        // Add volume tube
                        const tubeRad = 2;
                        x += (Math.random()-0.5) * tubeRad;
                        y += (Math.random()-0.5) * tubeRad;
                        z += (Math.random()-0.5) * tubeRad;
                    }
                    break;

                    case 4: // Grandi's Rose (Rhodonea) k=4
                    {
                        const k = 4;
                        // Use spherical coords to make it a 3D flower
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        
                        // 2D polar r = cos(k*theta)
                        let r2d = Math.cos(k * theta) * scale * 1.5;
                        
                        // Map to sphere surface roughly
                        x = r2d * Math.cos(theta);
                        y = r2d * Math.sin(theta);
                        z = (Math.random() - 0.5) * 5; // thickness
                    }
                    break;

                    case 5: // Astroid (3D Star shape)
                    {
                         // x = a cos^3 t, y = a sin^3 t
                         // 3D generalization
                         const theta = Math.random() * Math.PI * 2;
                         const phi = Math.random() * Math.PI * 2;
                         const s = scale * 1.2;
                         
                         x = s * Math.pow(Math.cos(theta), 3) * Math.pow(Math.cos(phi), 3);
                         y = s * Math.pow(Math.sin(theta), 3) * Math.pow(Math.cos(phi), 3);
                         z = s * Math.pow(Math.sin(phi), 3);
                    }
                    break;

                    case 6: // Butterfly Curve (Transcendental)
                    {
                        const t = (i / PARTICLE_COUNT) * 12 * Math.PI;
                        const e = 2.71828;
                        // Fay's Butterfly
                        const term1 = Math.exp(Math.cos(t));
                        const term2 = 2 * Math.cos(4*t);
                        const term3 = Math.pow(Math.sin(t/12), 5);
                        
                        const r = term1 - term2 + term3;
                        const s = scale * 0.8;
                        
                        x = s * Math.sin(t) * r;
                        y = s * Math.cos(t) * r;
                        z = s * Math.sin(t/2) * 2; // Adding Z depth
                        y -= 5;
                    }
                    break;

                    case 7: // Julia Set (Approximated as a Strange Attractor / Cloud)
                    {
                        // Using Inverse Iteration Method to generate a fractal dust
                        // or a Lorentz Attractor for the "Chaos" look.
                        // Let's do a Lorentz Attractor for true 3D fluid beauty.
                        
                        // Initialize first point if i=0, else use previous
                        if (i === 0) {
                             // Reset global temporary vars for attractor
                             window.lx = 0.1; window.ly = 0; window.lz = 0;
                        }
                        
                        const dt = 0.005;
                        const sigma = 10;
                        const rho = 28;
                        const beta = 8/3;
                        
                        let dx = sigma * (window.ly - window.lx);
                        let dy = window.lx * (rho - window.lz) - window.ly;
                        let dz = window.lx * window.ly - beta * window.lz;
                        
                        window.lx += dx * dt;
                        window.ly += dy * dt;
                        window.lz += dz * dt;
                        
                        // Center and scale
                        x = window.lx * 0.8;
                        y = (window.ly * 0.8);
                        z = (window.lz * 0.8) - 20; 
                    }
                    break;
                }

                targetPositions.push(x, y, z);
            }
        }

        // --- Interaction Logic ---
        function nextShape() {
            currentShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
            updateHUD(SHAPES[currentShapeIndex]);
            
            // Trigger visual feedback
            const statusEl = document.getElementById('status-text');
            statusEl.innerText = "MORPHING...";
            statusEl.style.color = "#ff0";
            
            generateTarget(currentShapeIndex);
            
            setTimeout(() => {
                statusEl.innerText = "STABLE";
                statusEl.style.color = "#0f0";
            }, 1500);
            
            // Clear previous AI logs
            document.getElementById('ai-output').innerHTML = "Waiting for query...<span class='cursor'></span>";
        }

        let speedToggle = false;
        function toggleSpeed() {
            speedToggle = !speedToggle;
            const btn = document.getElementById('btn-speed');
            const disp = document.getElementById('speed-display');
            
            if(speedToggle) {
                morphSpeed = 0.15; // Fast
                controls.autoRotateSpeed = 8.0;
                btn.innerText = "NORMALIZE SPEED";
                btn.style.borderColor = "#f0f";
                btn.style.color = "#f0f";
                disp.innerText = "5.0x [WARP]";
                disp.style.color = "#f0f";
                
                // Increase bloom temporarily
                composer.passes[1].strength = 3.5;
            } else {
                morphSpeed = ANIMATION_SPEED_BASE;
                controls.autoRotateSpeed = 1.0;
                btn.innerText = "SPEED BOOST";
                btn.style.borderColor = "#0ff";
                btn.style.color = "#0ff";
                disp.innerText = "1.0x";
                disp.style.color = "#fff";
                
                composer.passes[1].strength = 2.0;
            }
        }

        function updateHUD(name) {
            document.getElementById('shape-name').innerText = name;
            // Glitch effect on text change
            const title = document.querySelector('h1');
            title.style.textShadow = "2px 0 red, -2px 0 blue";
            setTimeout(() => title.style.textShadow = "0 0 10px #0ff", 200);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Main Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const delta = now - lastTime;

            // Update FPS roughly every 500ms
            frameCount++;
            if (delta >= 500) {
                document.getElementById('fps-counter').innerText = Math.round((frameCount * 1000) / delta);
                frameCount = 0;
                lastTime = now;
            }

            controls.update();

            // Morph Logic
            const positionsAttribute = geometry.attributes.position;
            const array = positionsAttribute.array;
            let needsUpdate = false;

            for(let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                const tx = targetPositions[ix];
                const ty = targetPositions[iy];
                const tz = targetPositions[iz];

                // Lerp towards target
                // x += (target - current) * speed
                const distSq = (tx - array[ix])**2 + (ty - array[iy])**2 + (tz - array[iz])**2;
                
                if (distSq > 0.01) {
                    array[ix] += (tx - array[ix]) * morphSpeed;
                    array[iy] += (ty - array[iy]) * morphSpeed;
                    array[iz] += (tz - array[iz]) * morphSpeed;
                    needsUpdate = true;
                }
            }

            if (needsUpdate) {
                positionsAttribute.needsUpdate = true;
            } else {
                // Subtle breathing animation when stable
                if(!speedToggle) {
                    const time = Date.now() * 0.001;
                    scene.rotation.z = Math.sin(time * 0.1) * 0.05;
                }
            }

            // Optional: Dynamic Color pulsing based on shape
            // (omitted for performance, utilizing bloom instead)

            composer.render();
        }

        // Boot
        init();

    </script>
</body>
</html>